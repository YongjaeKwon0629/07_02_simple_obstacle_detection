# 배열 인덱싱 및 슬라이싱

## 📌 3.1 개요
✔️NumPy 배열에서 인덱싱과 슬라이싱은 데이터 탐색, 수정, 전처리의 필수 도구입니다.  
✔️이러한 기능은 단순히 요소를 선택하는 것을 넘어서, 다차원 데이터의 효과적인 처리에 필수적입니다.

## 🔎 인덱싱 (Indexing)
- 인덱싱은 특정 요소를 선택하는 과정입니다.
- 다차원 배열에서는 각각의 차원에 대해 인덱스를 명시합니다.

### ✔️ 1D 인덱싱
```python
arr = np.array([10, 20, 30])
print(arr[1])  # → 20
```
- 첫 번째 차원의 두 번째 요소 선택

### ✔️ 2D 인덱싱
```python
arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr[1, 2])  # → 6
```
- 두 번째 행, 세 번째 열

### ✔️ 3D 인덱싱
```python
arr = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
print(arr[1, 0, 1])  # → 6
```
- 두 번째 블록, 첫 번째 행, 두 번째 열

## ✂️ 슬라이싱 (Slicing)
- 배열의 연속적인 부분을 추출합니다.
- 구문: `[start:end:step]`

### ✔️ 1D 슬라이싱
```python
arr = np.array([10, 20, 30, 40, 50])
print(arr[1:4])  # → [20 30 40]
```

### ✔️ 2D 슬라이싱
```python
arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr[0, 1:3])  # → [2 3]
```

---

## ■ 3.2 이론적 배경
-  NumPy 배열은 stride 기반 메모리 모델을 사용합니다.

-  슬라이싱은 메모리 복사 없이 stride 값만 변경하여 View(뷰)를 반환합니다.

-  팬시 인덱싱은 stride를 사용할 수 없어서 메모리 복사가 발생합니다.

✔️ → 인덱싱과 슬라이싱은 메모리 접근의 효율성과 메모리 사용량에 직접적인 영향을 미칩니다.  

---  

## ■ 3.3 동작 원리
-  단일 인덱싱: ```arr[2,3]``` → 특정 요소 선택

-  슬라이싱: ```arr[1:, :2]``` → 행 방향 1번 인덱스부터 끝까지, 열 방향 0번~1번 선택

-  불리언 인덱싱: 조건에 맞는 값만 선택

-  팬시 인덱싱: 배열이나 리스트 형태의 인덱스로 복잡한 요소 선택

✔️ 슬라이싱은 stride 값을 조정해서 동작 → 원본 데이터와 메모리 공유
✔️ 팬시 인덱싱은 메모리 복사 발생

## ■ 3.4 수학적 원리 및 메모리 구조

-  메모리 주소 공식:
  
```
address = base_address + Σ (index_i * stride_i)
```
--
| 인덱싱 방식  | 메모리 복사 | 메모리 공유 | 속도    |
| ------- | ------ | ------ | ----- |
| 슬라이싱    | X      | O      | 매우 빠름 |
| 팬시 인덱싱  | O      | X      | 느림    |
| 불리언 인덱싱 | O      | X      | 중간    |
--  

✔️ 슬라이싱은 strides만 변경
✔️ 팬시 인덱싱은 새로운 배열 메모리 할당

■ 3.5 활용 사례
이미지 데이터에서 특정 영역 자르기

시계열 데이터에서 특정 기간 선택

조건부 필터링 (예: 결측값 제외)

머신러닝 배치 처리, 마스킹 연산

■ 3.6 코드 예시
python
코드 복사
import numpy as np

arr = np.arange(1, 13).reshape(3, 4)
print("원본 배열:\n", arr)

# 슬라이싱
sub_arr = arr[1:, 2:]
print("슬라이싱 결과:\n", sub_arr)

# 인덱싱
print("요소 접근:", arr[2, 3])

# 불리언 인덱싱
bool_arr = arr[arr > 5]
print("5보다 큰 값들:", bool_arr)

# 팬시 인덱싱
fancy_arr = arr[[0, 2], [1, 3]]
print("팬시 인덱싱 결과:", fancy_arr)
■ 3.7 출력 예시
lua
코드 복사
원본 배열:
 [[ 1  2  3  4]
  [ 5  6  7  8]
  [ 9 10 11 12]]
슬라이싱 결과:
 [[ 7  8]
  [11 12]]
요소 접근: 12
5보다 큰 값들: [ 6  7  8  9 10 11 12]
팬시 인덱싱 결과: [2 12]
■ 3.8 주의사항 및 한계
슬라이싱은 원본 배열과 메모리를 공유 → 수정 시 원본도 변경됨

팬시 인덱싱은 메모리 복사 → 성능 저하 가능

슬라이싱 후 복사하려면 .copy() 명령어 사용 필수



## 🚀 활용도
- 대규모 데이터셋에서 필요한 부분만 선택하여 메모리 최적화
- 피처 엔지니어링, 텍스트 처리, 이미지 데이터 슬라이싱 등에 활용

---
