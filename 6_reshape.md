# 🔸 배열 형태 변경 (Reshape)

##  📌6.1 개요
-  Reshape는 배열의 데이터는 유지하면서 **shape (배열 차원)**만 변경하는 기능입니다.
---

## 🔍 6.2 이론적 배경

-  NumPy 배열은 메모리 상 연속된 블록으로 저장됩니다.

→ 따라서 요소 수만 유지된다면 차원 변경은 stride만 조정하면 가능 → 메모리 복사 없이 빠름.

---

## 🔁 6.3 동작 원리
-  reshape는 메모리 연속성 여부에 따라 View 반환 (복사 없음) 또는 Copy 반환 (복사 발생)

-  메모리 연속성이 없는 배열은 reshape 시 메모리 복사 발생

✔️ ravel() → 가능한 View 반환

✔️ flatten() → 항상 Copy 반환

---

## 🔍 6.4 수학적 원리 및 메모리 구조

| 원본 Shape | 대상 Shape | 요소 수 동일 여부 | 메모리 복사 여부 |
| -------- | -------- | ---------- | --------- |
| (2, 3)   | (3, 2)   | ✅          | ❌ View    |
| (2, 3)   | (6,)     | ✅          | ❌ View    |
| (2, 3)   | (2, 2)   | ❌          | ❌ 불가능     |

✔️ 요소 수가 맞지 않으면 reshape 불가 → ValueError 발생

---

## ■ 6.5 활용 사례

-  딥러닝: (배치, 채널, 높이, 너비) ↔ (배치, 높이, 너비, 채널)

-  이미지 데이터: 2D ↔ 1D 플래튼(flatten)

-  시계열 데이터: (시간, 변수) ↔ (변수, 시간)
  
---

## ■ 6.6 코드 예시

```
import numpy as np

arr = np.arange(6)
reshaped = arr.reshape(2, 3)

# 플래튼
flatten = arr.flatten()

print("원본:", arr)
print("Reshape (2,3):\n", reshaped)
print("Flatten:", flatten)
```
---

## ■ 6.7 출력 예시

```
원본: [0 1 2 3 4 5]
Reshape (2,3):
 [[0 1 2]
  [3 4 5]]
Flatten: [0 1 2 3 4 5]
```

---

## 🔍 6.8 주의사항 및 한계
-  요소 개수가 맞지 않는 경우 reshape 불가

-  메모리 연속성 없는 배열은 reshape 시 Copy 발생 → 성능 저하

-  flatten()은 항상 Copy → 대용량 데이터는 메모리 주의

---  

## 🚀 활용도
- 딥러닝에서 입력 데이터 형식 변환 (예: 이미지 → (28,28))
- 시계열 데이터 → (batch_size, time_step, feature)로 변경
